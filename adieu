#!/usr/bin/env node

let fs = require('fs')
let path = require('path')
let meta = require('./package.json')
let cmd = require('commander')
let cheerio = require('cheerio')

function main() {
    let collect = (val, memo) => { memo.push(val); return memo; }
    cmd.version(meta.version)
        .usage('[options] [file.html | URL]')
	.option('-e, --eval <code>', 'JS')
	.option('-p, --print', 'automatically console.log the result form -e')
	.option('-r, --require <module>', 'preload a module', collect, [])
	.parse(process.argv)

    let src = cmd.args[0] || '/dev/stdin'
    parse(src).then( $ => {
	let sandbox = {
	    p: console.log.bind(console),
	    puts, $
	}
	Object.assign(sandbox, preload(cmd.require)) // modules
	return sandbox

    }).then( sandbox => {
	if (cmd.eval) {
	    let r = evaluate(cmd.eval, sandbox)
	    if (cmd.print) console.log(r)
	} else {
	    if (src === '/dev/stdin')
		throw new Error('repl mode requires a file/url argument')
	    irb(sandbox)
	}
    }).catch(err)
}

async function parse(input) {
    let fetch = async input => { new URL(input); return my_fetch(input); }
    let html = fetch(input).catch( e => {
	if (e instanceof TypeError) return fs.readFileSync(input)
	throw e
    })
    return cheerio.load(await html)
}

function err(s) {
    console.error(progname(), 'error:', s instanceof Error ? s.message : s)
    process.exit(1)
}

function preload(list) {
    let varname = s => s.replace(/[^\w]/g, '_')
    return list.reduce( (acc, cur) => {
	acc[varname(cur)] = require(cur)
	return acc
    }, {})
}

function puts(str) { process.stdout.write(String(str)); }

function evaluate(str, sandbox) {
    let vm = require('vm')
    vm.createContext(sandbox)
    return vm.runInContext(str, sandbox)
}

function irb(sandbox) {
    let repl = require('repl')
    console.error('Your document should be available via $')
    let r = repl.start('> ')
    Object.assign(r.context, sandbox)
    if (r.setupHistory) {	// since node 11.10.0
	let xdg = require('xdg-basedir')
	let file = path.join(xdg.cache, progname(), 'history')
	fs.mkdirSync(path.dirname(file), {recursive: true})
	r.setupHistory(file, () => {})
    }
}

function my_fetch(url, opt) {
    let fetcherr = r => {
	if (!r.ok) throw new Error(r.status)
	return r
    }
    return require('node-fetch')(url, opt).then(fetcherr).then( r => r.text())
}

function progname() { return path.basename(process.argv[1]); }

main()
